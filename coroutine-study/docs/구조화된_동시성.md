## 구조화된 동시성 
launch 또는 async 등의 코루틴 빌더를 이용하면 Job객체를 항상 새롭게 생성한다. 
이는 코루틴 제어에 Job객체가 필요하기 때문이다.

하지만 부모 코루틴의 Job은 자식 코루틴의 참조를 가지고 있으며 자식 코루틴의 Job은 부모 코루틴의 Job을 참조로 가지고 있다.
```kotlin
fun main() = runBlocking<Unit> {
    val parentJob = coroutineContext[Job]

    launch {
        val childJob = coroutineContext[Job]
        if (parentJob === childJob) {
            println("runBlocking으로 생성된 Job과 launch로 생성된 Job이 동일합니다.")
        } else {
            println("runBlocking으로 생성된 Job과 launch로 생성된 Job이 다릅니다.")
        }

        println("1. 자식 코루틴의 Job이 가지고 있는 parent는 부모 코루틴의 Job인가? ${childJob?.parent == parentJob}")
        println("2. 부모 코루틴의 Job은 자식 코루틴의 Job을 참조로 가지는가? ${parentJob?.children?.contains(childJob)}")
    }
}
```

### 특정 코루틴을 CoroutineScope 범위에서 벗어나게 하기
```kotlin
1. 새로운 CoroutineScope 만들기 [SeparateCoroutine.kt]
fun main() = runBlocking<Unit> { 
    launch(CoroutineName("Coroutine1")) {
        laucnh(CoroutineName("Coroutine3")) {
            println("[${Thread.currentThread().name}] 코루틴 실행")
        }
    }
    CoroutineScope(Dispatchers.IO).launch(CoroutineName("Coroutine4")) {
        println("[{Thread.currentThread().name}] 코루틴 실행")
    }
    
    launch(CoroutineName("Coroutine2")) {
        println("[{Thread.currentThread().name}] 코루틴 실행")
    }
}
```

2. 새로운 Job만들기 [SeparateCoroutine2.kt]
```kotlin
fun main() = runBlocking {
    val newRootJob = Job()
    launch(CoroutineName("Coroutine1") + newRootJob) {
        launch(CoroutineName("Coroutine3") + newRootJob) {
            delay(1000L)
            println("[${Thread.currentThread().name}] 코루틴 실행")
        }
    }
    launch(CoroutineName("Coroutine4") + newRootJob) {
        delay(1000L)
        println("[${Thread.currentThread().name}] 코루틴 실행")
    }

    launch(CoroutineName("Coroutine2") + newRootJob) {
        launch(CoroutineName("Coroutine5") + Job()) {
            delay(1000L)
            println("[${Thread.currentThread().name}] 코루틴 실행")
        }
    }

    delay(50L)
    newRootJob.cancel()
    delay(1000L)
}
```
** 주의 **
생성 함수로 생성된 Job객체는 자동으로 실행 완료되지 않기 때문에 명시적으로 complete함수를 호출 해줘야 한다.
```kotlin
fun main(): kotlin.Unit = runBlocking {
    launch(CoroutineName("Coroutine1")) {
        val coroutineJob = this.coroutineContext[Job]
        val newJob = Job(coroutineJob)
        launch(CoroutineName("Coroutine2") + newJob) {
            delay(100L)
            println("[${Thread.currentThread().name}] 코루틴 실행")
        }
        // newJob.complete()
    }
}
```
- 주석을 해제하지 않으면 프로세스가 종료되지 않음.


### 코루틴의 취소 
- 코루틴의 취소가 요청되면 자식 코루틴에 취소가 전파된다. 
 