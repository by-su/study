## 정적 팩토리 메서드를 사용하면 좋은점
```java
@Getter
public final class Member {
    private String email;

    private String nickname;

    private String passwordHash;

    private MemberStatus status;

    // password를 생성자로 넣어버리면 내부에 저장되는 것 처럼 보임
    private Member(String email, String nickname, String passwordHash) {
        this.email = Objects.requireNonNull(email);
        this.nickname = Objects.requireNonNull(nickname);
        this.passwordHash = passwordHash;

        this.status = MemberStatus.PENDING;
    }

    public static Member create(String email, String nickname, String password, PasswordEncoder passwordEncoder) {
        return new Member(email, nickname, passwordEncoder.encode(password));
    }

    ...
}
```
1. 생성자 이름보다 의미 있는 이름을 제공할 수 있다. 
2. 캡슐화와 보안: 객체 생성 시점에 암호화/인코딩과 같은 복잡한 초기화 로직을 캡슐화할 수 있습니다.
3. 유연성 및 확장성 증가
   - 기존 클래스를 수정하지 않고 반환되는 객체의 타입을 변경할 수 있다. Member 클래스가 인터페이스를 구현하게 되는 경우 create 메서드만 호출하면 된다.
   - 캐싱이나 싱글턴 패턴을 구현하는 등 객체 생성 로직을 더욱 세밀하게 제어할 수 있다.
    ```java
    public static Member create(String email, String nickname, String password, PasswordEncoder passwordEncoder) {
        // 캐시에서 객체 찾기 (이메일을 키로 사용한다고 가정)
        String cacheKey = email; // 간단한 키 사용
        if (cache.containsKey(cacheKey)) {
            System.out.println("Returning cached member for: " + email);
            return cache.get(cacheKey);
        } else {
            System.out.println("Creating and caching new member for: " + email);
            // 새 객체 생성
            String encodedPassword = passwordEncoder.encode(password);
            Member newMember = new Member(email, nickname, encodedPassword);
            // 캐시에 추가
            cache.put(cacheKey, newMember);
            return newMember;
        }
    }
    ```

## 파라미터 값을 잘 못 넣기 막기 
파라미터가 증가하면서 호출하는 쪽에서 파라미터를 잘 못 넣을 수 있는 문제가 존재. 이를 어떻게 해결할 수 있을까 ?
```java
public static Member create(String email, String nickname, String password, PasswordEncoder passwordEncoder) {
    return  new Member(email, nickname, passwordEncoder.encode(password));
}
```

1. 빌더 패턴: 파라미터를 3개 넣어야 하는데 2개만 넣은 경우 런타임에 에러가 날 수 있음. 
2. 파라미터 오브젝트 사용하기
    ```java
        public static Member create(MemberCreateRequest createRequest, PasswordEncoder passwordEncoder) {
            return  new Member(createRequest.email(), createRequest.nickname(), passwordEncoder.encode(createRequest.password()));
        }
    ```
    다음과 같은 경우에도 파라미터 순서가 바뀌는 위험이 있을 수 있으니 create()가 생성을 담당하는게 좋을 수 있음.

    ```java
        public static Member create(MemberCreateRequest createRequest, PasswordEncoder passwordEncoder) {
            Member member = new Member();
            member.email = Objects.requireNonNull(createRequest.email());
            member.nickname = Objects.requireNonNull(createRequest.nickname());
            member.passwordHash = Objects.requireNonNull(passwordEncoder.encode(createRequest.password()));
    
            member.status = MemberStatus.PENDING;
            
            return member;
        }
    ```

## Value Object
이메일 검증 로직이 추가되었다고 해보자.

```java
public static Member create(MemberCreateRequest createRequest, PasswordEncoder passwordEncoder) {
    Member member = new Member();
    String email = createRequest.email();

    String emailRegex = "^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$";
    if (!email.matches(emailRegex)) {
        throw new IllegalArgumentException("올바른 이메일 형식이 아닙니다.");
    }

    member.email = Objects.requireNonNull(email);
    member.nickname = Objects.requireNonNull(createRequest.nickname());
    member.passwordHash = Objects.requireNonNull(passwordEncoder.encode(createRequest.password()));

    member.status = MemberStatus.PENDING;

    return member;
}
```
이메일 검증 로직이 생성할 때 뿐만 아니라 변경, 인증 등에도 사용될 것 같다. 응집도를 높이기 위해 클래스로 분리할 수 있다. 여기서 Email 객체는 Value Object가 된다.

Value Object란
- 도메인 모델에서 식별자가 필요하지 않고 속성/값으로만 구별되는 오브젝트
- 엔티티가 너무 많은 책임을 가지는 것을 방지하고 특정 속셩 관련 행위를 분리해서 엔티티를 더 집중된 상태로 유지하게 한다. 
- 상태 변경이 필요하다면 새로운 객체를 생성해서 교체한다.

```java
public record Email(String address) {
    private static final String EMAIL_PATTERN = "^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$";
    public Email {
        if (!address.matches(EMAIL_PATTERN)) {
            throw new IllegalArgumentException("올바른 이메일 형식이 아닙니다.");
        }
    }
}

```

