## 리액티브 시스템 설계 원칙
Spring WebFlux를 통해 리액티브 시스템의 4가지 핵심 원칙(Reactive Manifesto)이 어떻게 구현되는지 살펴보자.

### 1. 응답성 (Responsiveness)
> 빠르고 일관된 응답 시간을 제공해야 한다.

응답성은 사용자 경험의 핵심입니다. 시스템은 정상 상황과 오류 상황 모두에서 예측 가능한 응답 시간을 유지해야 합니다.

```kotlin
@RestController
class UserController(private val userService: UserService) {
    
    @GetMapping("/users/{id}")
    fun getUser(@PathVariable id: String): Mono<UserResponse> {
        return userService.findById(id)
            .map { UserResponse.from(it) }
            .timeout(Duration.ofSeconds(3)) // 3초 이내 응답 보장
            .onErrorResume(TimeoutException::class.java) { 
                // 타임아웃 발생 시 명확한 에러 응답
                Mono.error(ResponseStatusException(HttpStatus.REQUEST_TIMEOUT, "요청 시간 초과"))
            }
    }
}
```
- 이벤트 루프 모델: Netty의 이벤트 루프를 사용하여 적은 수의 스레드로 많은 요청을 동시에 처리
- 논블로킹 I/O: 스레드가 I/O 대기로 블로킹되지 않아 리소스를 효율적으로 사용
- 백프레셔: Publisher가 Subscriber의 처리 속도에 맞춰 데이터를 전송하여 시스템 과부하 방지
- 타임아웃 설정: 응답 시간을 예측 가능하게 제어

### 2. 회복성 (Resilience)
> 시스템은 장애 발생 시에도 응답성을 유지해야 한다.

회복성은 부분적인 장애가 전체 시스템으로 전파되는 것을 막습니다. 격리, 재시도, 폴백 전략을 통해 구현됩니다.

```kotlin
@Service
class CoinService(
    private val webClient: WebClient,
    private val fallbackCache: RedisCache // Mono<MarketData> 반환
) {
    private val logger = LoggerFactory.getLogger(CoinService::class.java)
    
    fun getMarketData(market: String): Mono<MarketData> {
        return webClient.get()
            .uri("/market/ticker?markets={market}", market)
            .retrieve()
            .bodyToMono<MarketData>()
            // 일시적 오류 발생 시 지수 백오프로 3번 재시도
            .retryWhen(Retry.backoff(3, Duration.ofSeconds(1))
                .maxBackoff(Duration.ofSeconds(10))
                .filter { it is WebClientException }
            )
            // 3번 재시도 모두 실패 시 캐시된 데이터 반환
            .onErrorResume { error ->
                logger.warn("API 호출 실패, 캐시 데이터 사용: market={}", market, error)
                fallbackCache.get(market)
            }
            // 캐시에도 데이터가 없으면 기본값 반환
            .switchIfEmpty(Mono.just(MarketData.default(market)))
    }
}
```

**회복성 구현 전략:**
- 재시도(Retry): 일시적 장애에 대응하여 자동으로 재시도
- 폴백(Fallback): 장애 시 대체 데이터 소스 사용
- 격리(Isolation): 한 컴포넌트의 장애가 다른 컴포넌트에 영향을 주지 않도록 분리

### 3. 탄력성 (Elasticity)
> 작업량이 변화하더라도 시스템이 응답성을 유지할 수 있어야 한다.

탄력성은 트래픽 변화에 따라 시스템이 자원을 효율적으로 조정할 수 있는 능력입니다. Spring WebFlux는 적은 수의 스레드로 많은 동시 요청을 처리할 수 있어 수평적 확장이 용이합니다.

```kotlin
@Configuration
class WebClientConfig {
    
    @Bean
    fun webClient(): WebClient {
        // 커넥션 풀 설정으로 리소스 효율적 관리
        val connectionProvider = ConnectionProvider.builder("custom")
            .maxConnections(500) // 최대 동시 연결 수
            .pendingAcquireMaxCount(1000) // 대기 큐 크기 (트래픽 급증 시 버퍼링)
            .pendingAcquireTimeout(Duration.ofSeconds(30)) // 연결 대기 타임아웃
            .maxIdleTime(Duration.ofSeconds(20)) // 유휴 연결 유지 시간
            .build()
        
        val httpClient = HttpClient.create(connectionProvider)
            .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 5000)
            .responseTimeout(Duration.ofSeconds(5))
        
        return WebClient.builder()
            .clientConnector(ReactorClientHttpConnector(httpClient))
            .build()
    }
}
```

**탄력성이 제공되는 방식:**
- 커넥션 풀 관리: 트래픽 증가 시 대기 큐를 통해 요청을 버퍼링하고, 유휴 연결을 재사용하여 리소스를 효율적으로 관리
- 논블로킹 아키텍처: 스레드를 블로킹하지 않아 동일한 하드웨어로 더 많은 요청 처리 가능
- 백프레셔: 다운스트림 시스템의 처리 능력에 맞춰 데이터 흐름을 조절

### 4. 메시지 기반 (Message Driven)
> 컴포넌트 간 통신은 비동기 메시지 전달을 기반으로 해야 한다.

메시지 기반 통신은 컴포넌트 간의 느슨한 결합을 가능하게 하고, 시스템의 경계를 명확히 합니다. 이는 위치 투명성, 격리, 탄력성의 기반이 됩니다.

```kotlin
@Service
class MarketDataStreamService {
    
    // Sinks: Hot Publisher 생성 (여러 구독자에게 동일한 데이터 브로드캐스트)
    private val sink = Sinks.many().multicast()
        .onBackpressureBuffer<TickUpbit>(1000) // 구독자가 느릴 때 최대 1000개 버퍼링
    
    // Publisher: 데이터 발행
    fun publishMarketData(tick: TickUpbit) {
        sink.tryEmitNext(tick).orThrow()
    }
    
    // Subscriber: 데이터 구독
    fun subscribeMarketData(): Flux<TickUpbit> {
        return sink.asFlux()
            .share() // 여러 구독자와 스트림 공유
    }
}

@RestController
class MarketDataController(
    private val streamService: MarketDataStreamService
) {
    // SSE(Server-Sent Events)를 통한 실시간 스트리밍
    @GetMapping("/stream/market-data", produces = [MediaType.TEXT_EVENT_STREAM_VALUE])
    fun streamMarketData(): Flux<TickUpbit> {
        return streamService.subscribeMarketData()
            .delayElements(Duration.ofMillis(100)) // 클라이언트 부하 조절
    }
}
```

**메시지 기반 통신의 장점:**
- 비동기 처리: 발신자는 응답을 기다리지 않고 다음 작업 수행 가능
- 백프레셔 지원: `onBackpressureBuffer`를 통해 구독자가 처리할 수 있는 속도로 데이터 전송
- 논블로킹: 스레드가 메시지 전달을 기다리며 블로킹되지 않음
- 느슨한 결합: Publisher와 Subscriber가 서로의 구현을 알 필요 없음

**Blocking I/O와의 차이:**
- Blocking: 각 요청마다 스레드가 할당되고, I/O 대기 중 스레드가 유휴 상태로 대기
- Reactive: 소수의 스레드가 이벤트 루프를 통해 수천 개의 동시 연결 처리, I/O 대기 중에도 다른 작업 수행

## 정리

Spring WebFlux는 Reactive Streams 명세를 구현하여 리액티브 시스템의 4가지 핵심 원칙을 모두 만족합니다:

1. 응답성: 논블로킹 I/O와 타임아웃으로 일관된 응답 시간 제공
2. 회복성: 재시도, 폴백, 격리 전략으로 장애 전파 방지
3. 탄력성: 적은 리소스로 많은 요청을 처리하여 확장성 확보
4. 메시지 기반: Publisher-Subscriber 패턴으로 느슨한 결합과 백프레셔 구현

이러한 특성들은 현대의 고가용성, 대규모 트래픽 처리가 필요한 시스템에서 특히 유용합니다.


