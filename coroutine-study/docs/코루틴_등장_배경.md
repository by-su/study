## 1. 스레드와 한계

스레드는 기본적으로 **한 번에 하나의 작업만 수행**할 수 있다.

예:
사용자 A 데이터를 `A → B → C` DB에서 순차적으로 가져온다면?

```text
[스레드 1]
 A DB 조회  --->  B DB 조회  --->  C DB 조회  --->  완료
```

단일 스레드에서는 모든 I/O가 끝날 때까지 대기(Blocking).

➡️ 비효율성 → 해결책: **멀티스레드**

```kotlin
val thread = Thread {
    println("작업 실행 중")
}
thread.start() // 반드시 start()를 호출해야 병렬 실행
```

하지만, 스레드 생성 비용은 크고 수천 개 단위로는 비효율적이다.
➡️ 그래서 **ExecutorService** 등장 (스레드 풀 재활용).

---

## 2. Executor의 한계

스레드 풀을 써도 여전히 블로킹 문제 존재.

```kotlin
val future = executorService.submit<String> {
    Thread.sleep(2000)
    "더미 결과값"
}
println(future.get()) // 결과 대기 = 블로킹 발생
```

➡️ `get()`은 **스레드를 묶어둠**.
➡️ `CompletableFuture`로 콜백은 가능하지만, 예외 처리 & 콜백 중첩 문제(콜백 지옥) 발생.

---

## 3. 스레드 전환의 비용

스레드는 무겁고, 문맥 전환 비용(Context Switching)이 비싸다.

```text
Th1   ===작업1===       (대기)         ===작업1 계속===
Th2          (대기)   ===작업2===
```

문제: 작업1이 I/O 대기 중일 때, 다른 작업으로 부드럽게 전환하기 어려움.

---

## 4. 코루틴의 등장 🚀

코루틴은 **경량 스레드**처럼 동작하며,
스레드의 제어권을 **양보(suspension)** 해서 블로킹을 피한다.

```text
[코루틴 실행 흐름]

코루틴 A ---작업 진행--- (suspend!) ---->
                                \
                                 (다른 코루틴 실행)
                                /
코루틴 A <---재개(resume)---------
```

➡️ 실제 스레드는 그대로, 코루틴만 “잠시 멈췄다가 다시 시작” 가능.

---
