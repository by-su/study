# 개념 공부

## topic
> 데이터가 저장되는 공간이다.

다음과 같은 이유로 데이터는 1개 이상의 파티션으로 구성된다.
- 토픽이 하나의 파티션으로만 구성된다면, 그 토픽의 크기는 해당 데이터를 저장하는 브로커 한 대의 디스크 용량으로 제한된다. 
- 싱글 큐 구조에서는 여러 생산자다 동시에 쓰기 작업을 할 때 파일 시스템의 Lock 경합이나 디스크 I/O 병목이 심하게 발생한다.
- 파티션은 컨슈머 그룹 내에서 병렬 처리의 단위가 되기 때문에, 파티션을 나누어야만 여러 대의 컨슈머가 동시에 데이터를 처리하여 지연(Lag)을 방지할 수 있다.

다만 파티션의 수를 무조건 늘리게 되면 장애 복구시 리더 선출 시간이 길어지거나 파일 핸들 수 증가 등의 오버헤드가 발생할 수 있으므로 비즈니스 요구사항과 처리량에 맞춘 적절한 파티션 설계가 중요하다.


## Consumer Group
> 동일한 Group ID를 공유하는 컨슈며들의 집합입니다. 

### 목적
- 병렬 처리: 하나의 토픽 데이터를 여러 컨슈머가 나누어 처리 
- 고가용성: 그룹 내 컨슈머 하나가 장애가 나면, 다른 컨슈머가 해당 파티션을 이어받아 처리(리밸런싱)
- 오프셋 관리: "그룹 단위로 어디까지 읽었는지 기록"하므로, 컨슈머가 재시작되어도 마지막 지점부터 다시 읽을 수 있음

### 시나리오별 동작 분석
토픽: order-events (파티션 3개)
```text
파티션 0: [주문1, 주문2, 주문3]
파티션 1: [주문4, 주문5, 주문6]
파티션 2: [주문7, 주문8, 주문9]
```

#### 시나리오 1: Consumer 2대, 같은 그룹
```text
Consumer A (group: order-processor)
Consumer B (group: order-processor)

Consumer A → 파티션 0, 1 담당
Consumer B → 파티션 2 담당
```

#### 시나리오 2: Consumer 2대, 다른 그룹
```text
Consumer X (group: analytics-team)
Consumer Y (group: notification-team)
```

```text
Consumer X → 파티션 0, 1, 2 **모두** 읽음
Consumer Y → 파티션 0, 1, 2 **모두** 읽음
```