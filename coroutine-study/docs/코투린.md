# 코루틴

스레드는 한 번에 하나의 작업만 수행 가능 
스레드가 하나인데 오래 걸리는 작업을 한다면 ? 

사용자 A에 대한 데이터를 A,B,C 데이터베이스에서 가져오는 경우 ? 
단일 스레드는 A -> B -> C 

이런 비효율성을 줄이기 위해 멀티 스레드를 사용할 수 있음. 

자바에서는 Thread 클래스를 이용해 새로운 스레드를 생성하고 작업을 수행할 수 있음. 
- start()를 해야 새로웅ㄴ 스레드를 생성하고 작업을 실행함.

하지만 매번 Thread를 생성하는 것은 비효율적이기 때문에 스레드를 미리 어느정도 생성하고 재활용하는 방식의 
Executor프레임워크를 사용함. 

근데 이 executor의 한계도 존재함. 스레드 블로킹이 일어난다는거임. 
결과를 받기 위해서 get()을 하는 경우 
````json
executorService.submit<String> { 
  Thread.sleep(2000)
          return@submit "더미 결과값"
}
future.get()
````

CompletableFuture를 사용해 콜백 형식으로 문제 해결할 수 있지만 콜백 지옥 생기고 예외 처리가 어려워진다. why?

스레드 기반 작업의 한계 
- 스레드 기반 작업들은 작업의 전환이 어렵고, 전환 비용이 비싸다
- 작업 간의 종속성이 복잡해 스레드 블로킹이 발생하는 것은 필연적

```text
Th1      ======작업1수행                작업1 마저 수행 | 작업3 수행
Th2      ============================
```
작업3을 작업1 수행 멈췄을 때 하면 좋겠지만 이를 처리하기는 매우 복잡함


코루틴을 이를 어떻게 해결할까?

코루틴에서는 코루틴이라 불리는 작업 단위를 사용한다.
 -> 코루틴은 스레드의 사용 권한을 양보할 수 있다.


코루틴 사용하기 
runBlocking은 해당 함수를 호출한 스레드를 사용해 작업한다.

fun main() = runBlocking<Unit> {
    println("Hello Coroutines")
}

코루틴 디버깅하기 
1. 콘솔 로그 사용하기
```text 
// VM Options에 다음 코드 활성화
-Dkotlinx.coroutines.debug
```

```text
[main @coroutine#1] runBlocking 코루틴 실행
[main @coroutine#2] launch 코루틴 실행
```

2. 중지점 만들기 
layout 버튼 클릭 후 코루틴 탭 활성화 


---

# 코루틴 정리 노트
1. [ 코루틴 등장 배경 ](코루틴_등장_배경.md)
2. [ 코루틴 기본 사용법 ]



---

## 핵심 요약

* 스레드는 무겁고 블로킹 문제 발생.
* Executor로도 한계 있음 (get(), 콜백 지옥).
* 코루틴은 경량 스레드, suspend/resume으로 **스레드 블로킹 없이 동시성** 구현.
* `delay()`는 스레드를 블록하지 않고 코루틴만 잠시 멈춤.
* 디버깅은 `-Dkotlinx.coroutines.debug` 옵션으로 추적 가능.

---

👉 이렇게 해 두면 다음에 보실 때, **스레드의 한계 → 코루틴의 장점 → 실제 코드 흐름**이 바로 떠오를 거예요.

원하시면, 제가 여기서 **`async/await` 예제랑 ASCII 그림**도 추가해드릴까요? (동시에 여러 DB에서 가져오는 케이스로)
